<script>
/**
 * Observer模式: 观察者(订阅者)和数据劫持结合使用, 观察对应的数据. 如果发生改变时, 将会接收到通知. 从而触发自身的update 方法
*/
//-------------------------------------------------------------------------------------------------------------------

/**
 * Reactive 数据响应 OR 数据劫持. 不是观察者哦
*/
class Observer {
  constructor(obj) {
    this.vm = obj
    this.observe(this.vm)
  }
  observe(obj) {
    if (!obj || typeof obj!=='object') {
      // 不是对象
      return
    }

    // obj是对象
    // 自身可遍历属性. 不包括Symbol
    Object.keys(obj).forEach(key => {
      this.defineReactive(key, obj[key], obj)
    })
  }
  defineReactive(key, val, obj) {
    this.observe(val) // 值也要递归一下

    let dep = new Dep()  // 收集依赖: 收集 数据的订阅者

    Object.defineProperty(obj, key, {
      get() {
        // getter时 收集该数据的 观察者(订阅者)
        if (Dep.target && Dep.target instanceof Watcher) {
          // 为什么要这步判断? 当Dep.target 是一个Watcher实例对象时, 说明 要开始对某个属性 观察了.  你没有Dep.target 那我干嘛观察呢?
          dep.addSub( Dep.target )
          console.log('收集成功', dep)
        }

        // get函数作用域链中 存在 闭包对象. -> defineReactive中val形参被放入闭包对象
        console.log(`获取了值. getter函数`)
        return val
      },
      set(newVal) {
        if (val === newVal) { return }

        // setter时, 该属性的 通知观察该属性的所有 Watcher们
        val = newVal
        dep.notify()

        console.log(`${key}被修改了, 新值是: ${newVal}`)
      }
    })
  }
}



/**
 * 观察者: 观察数据的
 * vm监听的对象. 具体的属性.  属性值改变时执行的回调函数
 * 先实现一个简单的,  一层属性. 
*/
class Watcher {
  constructor(vm, expr, cb) {
    this.vm = vm
    this.expr = expr
    this.cb = cb

    // 先获取一下值, 老值 - 触发对应属性的 getter. 
    // 获取数据的时候, 在 Dep添加 上 当前Watcher实例
    Dep.target = this
    this.oldVal = this.vm[this.expr]
    Dep.target = null
  }
  update() {
    let newVal = this.vm[this.expr] // 和oldVal 虽然代码是一样的, 但是当对象的值改变时. 再获取就不一样了.  即他们俩虽然张的一样, 但是执行时机不同.
    console.log('获取了 新值, 旧值', newVal, this.oldVal)
    if (this.oldVal === newVal) {
      return
    }

    // 不同
    console.log('观察者接收到通知, 数据变化.')
    this.cb(newVal)
  }
}



/**
 * 收集依赖  收集 和 通知的作用 将观察者 与 数据关联
 * 数据 getter时 收集订阅(观察)该数据的 Watcher. 放入到 subs数组
 * 数据 setter时, 通知该数据的 所有订阅者(Watcher)
*/
class Dep {
  constructor() {
    // 当前数据的 订阅者(观察者们)
    this.subs = []
  }
  addSub(watcher) {
    this.subs.push( watcher )
  }
  notify() {  // 通知该数据的 订阅者(观察者)们 数据更新了
    console.log('开始通知');
    this.subs.forEach(watcher => watcher.update())
  }
}



let data = {
  name: 'GWJ',
  age: 21
}

new Observer(data)

new Watcher(data, 'age', (newVal) => {
  console.log('第1个观察者 data.age改变了', newVal)
})
new Watcher(data, 'age', (newVal) => {
  console.log('第2个观察者 data.age改变了', newVal)
})
new Watcher(data, 'age', (newVal) => {
  console.log('第3个观察者 data.age改变了', newVal)
})







































</script>