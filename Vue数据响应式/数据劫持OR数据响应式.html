<script>

/**
 * defineReactive: 定义响应. 定义数据响应
 * 数据劫持 或者说 数据响应式: 即数据改变时 vm.data.age = 21
 * 会执行执行一些处理. 
*/
class Observer {
  constructor(obj) {
    this.vm = obj
    this.observe(this.vm)
  }
  observe(obj) {
    if (!obj || typeof obj!=='object') {
      // 不是对象
      return
    }

    // obj是对象
    // 自身可遍历属性. 不包括Symbol
    Object.keys(obj).forEach(key => {
      this.defineReactive(key, obj[key], obj)
    })
  }
  defineReactive(key, val, obj) {
    this.observe(val) // 值也要递归一下

    Object.defineProperty(obj, key, {
      get() {
        // get函数作用域链中 存在 闭包对象. -> defineReactive中val形参被放入闭包对象
        console.log(`获取了值. `)
        return val
      },
      set(newVal) {
        if (val === newVal) { return }
        console.log(`${key}被修改了, 新值是: ${newVal}`)
      }
    })
  }
}



// 为什么要用 类的形式. 工厂模式, 因为 我将来可能会监听多个 对象.


let data1 = {
  test: 'test',
  school: {
    name: 'GWJ',
    age: 21
  }
}
new Observer(data1)






































</script>